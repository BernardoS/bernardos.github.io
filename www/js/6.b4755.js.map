{"version":3,"sources":["webpack:///./utils/DOM/index.ts","webpack:///./utils/DOM/types.ts","webpack:///./utils/DOM/decorators.ts","webpack:///./utils/DOM/helpers.ts","webpack:///./web-components/highlight-text.ts","webpack:///./web-components/port-event.ts","webpack:///./web-components/port-list.ts","webpack:///./utils/DOM/component.ts"],"names":["Set","_attributes__WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","o","d","__webpack_exports__","customElement","name","options","TargetOrDescriptor","define","clazz","customElements","definedClasses","add","isHTMLElementClass","kind","_objectSpread","finisher","TypeError","isFunctionComponent","Object","getPrototypeOf","Function","prototype","createDocumentFragment","document","createElement","tag","is","createElementNS","FRAGMENT","getIs","attributes","undefined","createNode","has","concat","appendChild","node","child","HTMLTemplateElement","content","childNode","childToNode","Node","Text","createTextNode","toString","_typeof","Array","isArray","fragment","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","c","value","err","return","setAttribute","key","attribute","HTMLElement","SVGElement","Reflect","set","removeAttribute","toggleAttribute","isRefObject","refObj","Boolean","Target","isPrototypeOf","_decorate","_initialize","_HyperElement","F","[object Object]","super","arguments","this","static","decorators","_this","html","_templateObject","text","split","map","char","i","wire","_templateObject2","cn","test","HyperElement","port_event_templateObject","port_list_decorate","port_list_templateObject","_initialize2","_HyperElement2","port_list_templateObject2","styleSheets","WeakMap","shadows","hasShadow","component","getShadow","get","Component","constructor","_ref2","css","shadowRootInit","_defineProperty","attachShadow","Constructor","ShadowRoot","CSSStyleSheet","styleSheet","textContent","createStyleSheet","connectedCallback","role","shadow","adoptedStyleSheets","rules","length","replaceSync","append","cloneNode","addCSS","hasAttribute","tabIndex","addTabIndex","observedAttributesInitializer","attributeInitializer","initializeAttribute","upgradeProperty","renderization","appendRenderization","disconnectedCallback","attributeChangedCallback","hasOwnProperty","deleteProperty","_ref5","initializer","mode"],"mappings":"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","file":"js/6.b4755.js","sourcesContent":["import {NodeType, Reference} from './types'\nimport {getIs, createNode, setAttribute, appendChild, isRefObject, isFunctionComponent} from './helpers'\nimport {CustomAttributes} from './attributes'\n\nexport function css (literals: TemplateStringsArray, ...placeholders: string[]) {\n  return literals.raw[0]\n}\n\nconst customAttributesArray: Array<keyof CustomAttributes<Element>> = [\n  'ref',\n  'children'\n]\nconst customAttributesSet = new Set<string>(customAttributesArray)\n\nexport function hydrate(\n  tag: JSX.Tag<object>,\n  attributes: object | null,\n  ...children: NodeType[]\n): Node {\n  if (isFunctionComponent(tag)) {\n    return tag({...attributes, children})\n  }\n  const element = createNode(tag, getIs(attributes))\n  for (const child of children) appendChild(element, child)\n  if (element instanceof DocumentFragment) return element\n  if (attributes) {\n    for (const [key, attribute] of Object.entries(attributes)) {\n      if (!customAttributesSet.has(key)) {\n        setAttribute(element, key, attribute)\n      } else if (key === 'ref' && isRefObject(attribute)) {\n        Object.defineProperty(attribute, 'instance', {\n          configurable: true,\n          value: element\n        })\n      }\n    }\n  }\n  return element\n}\n\nexport function createRef<E extends Element>(): Reference<E> {\n  return {instance: undefined}\n}\n\nexport * from './types'\nexport * from './decorators'\nexport {default as Component, getShadow as getShadowRoot, hasShadow as hasShadowRoot} from './component'\nexport {FRAGMENT} from './helpers'\n","import * as Attrs from \"./attributes\";\n\n// export interface DOMElement {\n//   tag: string\n//   attributes: object\n// }\n\ninterface NodeArray extends Array<NodeType> {}\nexport type NodeType =\n| Node\n| Text\n| NodeArray\n| string\n| number\n| symbol\n| boolean\n| null\n| undefined\n\nexport interface Reference<E extends Element> {\n  readonly instance?: E\n}\n\nexport interface CustomElements {}\n\ndeclare global {\n  interface CSSStyleSheet {\n    replace (text: string): Promise<any>\n    replaceSync (text: string): any\n  }\n  interface DocumentOrShadowRoot {\n    adoptedStyleSheets: ReadonlyArray<CSSStyleSheet>\n    readonly styleSheets: StyleSheetList\n  }\n\n  export type FunctionComponent<Attrs extends object> = ((attrs: Attrs) => Node)\n\n  namespace JSX {\n    type Tag<Attrs extends object> = string\n      | FunctionComponent<Attrs>\n      | typeof globalThis.Element\n    interface Element extends HTMLOrSVGElement, globalThis.Element {}\n    interface ElementClass extends HTMLElement {}\n    interface ElementAttributesProperty {\n      __attributes: {};\n    }\n    interface ElementChildrenAttribute {\n      children: NodeType;\n    }\n    interface IntrinsicAttributes {}\n    interface IntrinsicClassAttributes<T> {}\n    interface IntrinsicElements extends CustomElements {\n      a: Attrs.HTMLAnchorElementAttributes\n      slot: Attrs.HTMLSlotElementAttributes\n      template: Attrs.HTMLElementAttributes<HTMLTemplateElement>\n      div: Attrs.HTMLElementAttributes<HTMLDivElement>\n      nav: Attrs.HTMLElementAttributes\n      style:  Attrs.HTMLStyleElementAttributes\n      span: Attrs.HTMLElementAttributes<HTMLSpanElement>\n      p: Attrs.HTMLElementAttributes<HTMLParagraphElement>\n      img: Attrs.HTMLImageElementAttributes\n      br: Attrs.HTMLElementAttributes<HTMLBRElement>\n      ul: Attrs.HTMLElementAttributes<HTMLUListElement>\n      li: Attrs.HTMLElementAttributes<HTMLLIElement>\n      section: Attrs.HTMLElementAttributes\n      h1: Attrs.HTMLElementAttributes<HTMLHeadingElement>\n      h2: Attrs.HTMLElementAttributes<HTMLHeadingElement>\n      h3: Attrs.HTMLElementAttributes<HTMLHeadingElement>\n      h4: Attrs.HTMLElementAttributes<HTMLHeadingElement>\n      html: Attrs.HTMLHtmlElementAttributes\n      head: Attrs.HTMLElementAttributes<HTMLHeadElement>\n      title: Attrs.HTMLElementAttributes<HTMLTitleElement>\n      meta: Attrs.HTMLMetaElementAttributes\n      link: Attrs.HTMLLinkElementAttributes\n      body: Attrs.HTMLBodyElementAttributes\n      script: Attrs.HTMLScriptElementAttributes\n      footer: Attrs.HTMLElementAttributes\n      main: Attrs.HTMLElementAttributes<HTMLElement>\n      details: Attrs.HTMLDetailsElementAttributes<HTMLDetailsElement>\n      summary: Attrs.HTMLElementAttributes<HTMLElement>\n      i: Attrs.HTMLElementAttributes<HTMLElement>\n      header: Attrs.HTMLElementAttributes<HTMLElement>\n      svg: Attrs.SVGSVGElementAttributes<SVGSVGElement>\n      path: Attrs.SVGPathElementAttributes<SVGPathElement>\n      g: Attrs.SVGElementAttributes<SVGGElement>\n      rect: Attrs.SVGRectElementAttributes<SVGRectElement>\n      text: Attrs.SVGTextElementAttributes<SVGTextElement>\n      tspan: Attrs.SVGTextElementAttributes<SVGTSpanElement>\n      button: Attrs.HTMLButtonElementAttributes<HTMLButtonElement>\n    }\n  }\n}\n\nexport * from \"./attributes\";\n","import { isHTMLElementClass, definedClasses } from './helpers';\nimport Component from './component'\n\ninterface ClassDescriptor<T> {\n  kind: 'class'\n  elements: Descriptor<T>[];\n  finisher?: (clazz: T) => undefined | T,\n  [Symbol.toStringTag]: \"Descriptor\"\n}\n\n// From the TC39 Decorators proposal\ninterface Descriptor<T> {\n  kind: 'field' | 'method' \n  key: PropertyKey\n  placement: 'static'|'prototype'|'own'\n  initializer?: () => unknown\n  extras?: Descriptor<T>[]\n  finisher?: (clazz: T) => undefined | T\n  descriptor: PropertyDescriptor,\n  [Symbol.toStringTag]: \"Descriptor\"\n}\n\n\nexport const customElement = (\n  name: string,\n  options?: ElementDefinitionOptions\n) => <T extends typeof HTMLElement>(TargetOrDescriptor: T | ClassDescriptor<T>) => {\n  const define = (clazz: T) => {\n    customElements.define(name, clazz, options)\n    definedClasses.add(clazz)\n  }\n  if (isHTMLElementClass(TargetOrDescriptor)) return define(TargetOrDescriptor)\n  if (TargetOrDescriptor.kind === 'class') {\n    return {...TargetOrDescriptor, finisher: define} as unknown as T\n  }\n  else throw new TypeError('customElement decorator can only be applied to classes that descend HTMLElement')\n}\n\nexport const attribute = (\n  attribute: string,\n  type: typeof String | typeof Boolean | typeof Number = String\n) => <T extends HTMLElement>(\n  elementOrDescriptor: T | Descriptor<typeof Component>,\n  property?: string\n) => {\n  if (elementOrDescriptor instanceof HTMLElement) return\n  const descriptor: Descriptor<typeof Component> = {\n    ...elementOrDescriptor,\n    placement: 'prototype',\n    kind: 'method',\n    descriptor: {\n      get (this: T) {\n        if (type === String) return this.getAttribute(attribute)\n        if (type === Number) return Number(this.getAttribute(attribute))\n        if (type === Boolean) return this.hasAttribute(attribute)\n      },\n      set (this: T, value: unknown) {\n        switch (type) {\n          case String: {\n            if (typeof value === 'string') {\n              return this.setAttribute(attribute, value)\n            }\n            throw new TypeError(`This property only accepts string as value, instead got ${typeof value}`)\n          }\n          case Number: {\n            if (typeof value === 'number') {\n              return this.setAttribute(attribute, value.toString())\n            }\n            throw new TypeError(`This property only accepts number as value, instead got ${typeof value}`)\n          }\n          case Boolean: {\n            this.toggleAttribute(attribute, Boolean(value))\n            return\n          }\n          default: {\n            if (typeof value === 'undefined') {\n              return this.removeAttribute(attribute)\n            }\n          }\n        }\n      }\n    },\n    initializer: undefined,\n    finisher: (clazz) => {\n      clazz.observedAttributesInitializer.add({\n        ...elementOrDescriptor,\n        attribute,\n      })\n      const observedAttributes = clazz.observedAttributes\n      Object.defineProperty(clazz, 'observedAttributes', {\n        configurable: true,\n        value: [...observedAttributes, attribute]\n      })\n      return clazz\n    }\n  }\n  return descriptor as unknown as void\n}\n","import { NodeType, Reference } from './types'\n\nexport const definedClasses = new Set<typeof Element>()\n\nexport const isFunctionComponent = (o: any): o is FunctionComponent<object> => {\n  return Object.getPrototypeOf(o) === Function.prototype\n}\n\nconst createDocumentFragment = () => {\n  return document.createDocumentFragment()\n}\nconst createElement = (tag: string, is?: string) => {\n  switch (tag) {\n    case \"svg\":\n    case \"path\":\n    case \"g\":\n    case \"rect\":\n    case \"text\":\n      return document.createElementNS(\"http://www.w3.org/2000/svg\", tag)\n    default:\n      return document.createElement(tag, { is })\n  }\n}\nexport const FRAGMENT = '@fragment' as const\n\nexport const getIs = (attributes: object | null) =>\nattributes && \"is\" in attributes\n  ? ((attributes as any).is as string)\n  : undefined\n\nexport function createNode(\n  tag: Exclude<JSX.Tag<object>, FunctionComponent<object>>,\n  is?: string\n) {\n  if (tag instanceof Function) {\n    if (definedClasses.has(tag)) return new tag()\n    else throw new TypeError(`Class ${tag.name} is not defined via DOM.customElement`)\n  }\n  switch (tag) {\n    case FRAGMENT:\n      return createDocumentFragment()\n    default:\n      return createElement(tag, is)\n  }\n}\n\nexport function appendChild(node: Node, child: NodeType) {\n  if (node instanceof HTMLTemplateElement) node = node.content\n  const childNode = childToNode(child)\n  if (childNode) node.appendChild(childNode)\n}\n\nfunction childToNode(child: NodeType): Node | null {\n  if (child instanceof Node) return child\n  if (child instanceof Text) return child\n  if (typeof child === \"string\") return document.createTextNode(child)\n  if (typeof child === \"number\")\n    return document.createTextNode(child.toString())\n  if (typeof child === \"symbol\")\n    return document.createTextNode(child.toString())\n  if (Array.isArray(child)) {\n    const fragment = document.createDocumentFragment()\n    for (const c of child) {\n      const node = childToNode(c)\n      if (node) fragment.appendChild(node)\n    }\n    return fragment\n  }\n  return null\n}\n\nexport function setAttribute<Attribute, E extends Element>(\n  node: E,\n  key: string,\n  attribute: Attribute\n) {\n  if (node instanceof HTMLElement || node instanceof SVGElement) {\n    switch (typeof attribute) {\n      case \"object\": {\n        throw new TypeError(\"objects not allowed\")\n      }\n      case \"function\": return Reflect.set(node, key, attribute)\n      case \"undefined\": {\n        return node.removeAttribute(key)\n      }\n      case \"boolean\": {\n        return node.toggleAttribute(key, attribute)\n      }\n      case \"string\":\n      case \"number\":\n      case \"bigint\":\n      case \"symbol\": {\n        return node.setAttribute(key, attribute.toString())\n      }\n      default: {\n        return node.removeAttribute(key)\n      }\n    }\n  }\n  throw new TypeError(`uncharted attribute type ${typeof attribute}`)\n}\n\n\nexport function isRefObject(refObj: any): refObj is Reference<Element> {\n  return Boolean(typeof refObj === 'object' && 'instance' in refObj)\n}\n\nexport const isHTMLElement = (Target: any): Target is HTMLElement =>\n  Target instanceof HTMLElement\n\nexport const isHTMLElementClass = (Target: any): Target is typeof HTMLElement =>\n  HTMLElement.prototype.isPrototypeOf(Target.prototype)\n","import HyperElement, {attribute, customElement} from '~/utils/hyper-element'\nimport cn from 'classnames'\n\n@customElement('highlight-text')\nexport class HighLightText extends HyperElement {\n  public static readonly css = /*css*/`\n    :host {\n      display: inline;\n    }\n    :host([hidden]) {\n      display: none;\n    }\n    .highlight {\n      color: var(--highlight-text-color);\n    }\n  `\n  @attribute('text')\n  public text: string = ''\n\n  public render () {\n    this.html`\n      ${this.text.split('').map((char, i) => this.wire(`${i}`)`\n        <span class=${cn(/^\\W+$/.test(char) && 'highlight')}>\n          ${char}\n        </span>\n      `)}\n    `\n  }\n}\n","import HyperElement, { customElement } from '~/utils/hyper-element';\n\n@customElement('port-event')\nexport default class PortEvent extends HyperElement {\n  public render () {\n    this.html`\n      <slot name=\"title\" class=\"title\"/>\n      <slot name=\"location\" class=\"location\"/>\n      <slot class=\"content\"/>\n      <slot name=\"timestamp\" class=\"timestamp\"/>\n    `\n  }\n  public static readonly css = /*css*/`\n    :host {\n      display: grid;\n      grid-template-columns: 1fr auto;\n      grid-template-areas:\n        \"title   location\"\n        \"content content\"\n        \".....   timestamp\";\n      grid-gap: var(--space);\n    }\n    :host([hidden]) {\n      display: none;\n    }\n    :host(:focus) {\n      outline: none;\n    }\n    slot {\n      display: block;\n    }\n    .title {\n      grid-area: title;\n    }\n    .location {\n      justify-self: end;\n      grid-area: location;\n    }\n    .timestamp {\n      grid-area: timestamp;\n      justify-self: end;\n    }\n    .content {\n      align-self: baseline;\n      grid-area: content;\n    }\n  `\n}\n","import HyperElement from '~/utils/hyper-element';\nimport { customElement } from '~/utils/DOM';\n\n@customElement('port-list')\nexport class PortList extends HyperElement {\n  public static readonly css = /*css*/`\n    :host {\n      display: block;\n      &:focus {\n        outline: none;\n      }\n    }\n    :host([hidden]) {\n      display: none;\n    }\n    :host(:focus) {\n      outline: none;\n    }  \n  `\n  public static readonly role = 'list'\n  public render () {\n    this.html`<slot/>`\n  }\n}\n\n@customElement('port-list-item')\nexport class PortListItem extends HyperElement {\n  public static readonly css = /*css*/`\n    :host {\n      display: flex;\n      align-items: center;\n      padding: var(--space);\n    }\n    :host([hidden]) {\n      display: none;\n    }\n    :host(:focus) {\n      outline: none;\n    }\n    .bullet {\n      flex: 0 0 auto;\n      box-sizing: border-box;\n      height: 6px;\n      width: 6px;\n      background-color: var(--port-list-item-bullet-color);\n      border-radius: 100%;\n      display: inline-block;\n      margin-right: var(--space);\n    }  \n  `\n  public static readonly role = 'listitem'\n  public render () {\n    this.html`\n      <span class=\"bullet\"/>\n      <span>\n        <slot/>\n      </span>\n    `\n  }\n}\n","import {HTMLElementAttributes} from './attributes'\n\nconst styleSheets = new WeakMap<typeof Component, CSSStyleSheet | HTMLStyleElement>()\n\nexport interface AttributeInitializer {\n  attribute: string,\n  key: PropertyKey,\n  initializer?: () => unknown\n}\n\nconst shadows = new WeakMap<Component, ShadowRoot>()\nexport function hasShadow(component: Component) {\n  return shadows.has(component)\n}\nexport function getShadow(component: Component) {\n  return shadows.get(component)\n}\n\nexport default abstract class Component<Attributes extends {} = {}> extends HTMLElement {\n  public static readonly observedAttributes: string[] = []\n  public static readonly observedAttributesInitializer = new Set<AttributeInitializer>()\n  public static readonly css?: string\n  public static readonly shadowRootInit: ShadowRootInit = {mode: 'open'}\n  public static readonly tabIndex?: number\n  public static readonly role?: string\n  private __attributes?: Attributes & HTMLElementAttributes<this>\n  constructor () {\n    super()\n    attachShadow(this)\n    createStyleSheet(this)\n    appendStyleSheet(this)\n  }\n  protected connectedCallback () {\n    addCSS(this)\n    addRole(this)\n    addTabIndex(this)\n    const {observedAttributesInitializer} = this.constructor as typeof Component\n    for (const attributeInitializer of observedAttributesInitializer) {\n      initializeAttribute(this, attributeInitializer)\n      upgradeProperty(this, attributeInitializer.key)\n    }\n    appendRenderization(this)\n  }\n  protected disconnectedCallback () {}\n  protected attributeChangedCallback () {}\n  protected abstract render? (): Element\n}\n\nfunction appendStyleSheet(component: Component) {\n}\n\nfunction createStyleSheet(component:Component) {\n  const Constructor = component.constructor as typeof Component\n  const {css} = Constructor\n  if (!styleSheets.has(Constructor) && shadows.has(component)) {\n    if ('adoptedStyleSheets' in ShadowRoot.prototype) {\n      styleSheets.set(Constructor, new CSSStyleSheet())  \n    } else {\n      const styleSheet = document.createElement('style')\n      styleSheet.textContent = css || ''\n      styleSheets.set(Constructor, styleSheet)\n    }\n  }\n}\n\nfunction attachShadow(component: Component) {\n  const {css, shadowRootInit} = component.constructor as typeof Component\n  if (component['render'] || css) {\n    shadows.set(component, component.attachShadow(shadowRootInit))\n  }\n}\n\nfunction appendRenderization (component: Component) {\n  if (component['render'] instanceof Function && hasShadow(component)) {\n    const shadow = getShadow(component)!\n    const renderization = component['render']()\n    shadow.append(renderization)\n  }\n}\n\n\nfunction addCSS(component:Component) {\n  const Constructor = component.constructor as typeof Component\n  const {css} = Constructor\n  if (styleSheets.has(Constructor) && typeof css === 'string' && hasShadow(component)) {\n    const styleSheet = styleSheets.get(Constructor)!\n    const shadow = getShadow(component)!\n    if (styleSheet instanceof CSSStyleSheet) {\n      shadow.adoptedStyleSheets = [styleSheet]\n      if (styleSheet.rules.length === 0) styleSheet.replaceSync(css)\n    } else {\n      shadow.append(styleSheet.cloneNode(true))\n    }\n  }\n}\n\nfunction addRole(component: Component) {\n  const {role} = component.constructor as typeof Component\n  if (!component.hasAttribute('role') && typeof role === 'string') {\n    component.setAttribute('role', role)\n  }\n}\n\nfunction addTabIndex(component:Component) {\n  const {tabIndex} = component.constructor as typeof Component\n  if (!component.hasAttribute('tabindex') && typeof tabIndex === 'number') {\n    component.tabIndex = tabIndex\n  }\n}\n\nfunction upgradeProperty(component: Component, key: PropertyKey) {\n  if (component.hasOwnProperty(key)) {\n    const value = Reflect.get(component, key)\n    Reflect.deleteProperty(component, key)\n    Reflect.set(component, key, value)\n  }\n}\n\nfunction initializeAttribute(component: Component, {key, initializer, attribute}: AttributeInitializer) {\n  if (initializer && !component.hasAttribute(attribute)) {\n    Reflect.set(component, key, initializer())\n  }\n}\n"],"sourceRoot":""}