{"version":3,"sources":["webpack:///../node_modules/@ungap/weakmap/esm/index.js","webpack:///../node_modules/@ungap/essential-weakset/esm/index.js","webpack:///../node_modules/@ungap/essential-map/esm/index.js","webpack:///../node_modules/domdiff/esm/utils.js","webpack:///../node_modules/domdiff/esm/index.js","webpack:///../node_modules/@ungap/custom-event/esm/index.js","webpack:///../node_modules/hyperhtml/esm/classes/Component.js","webpack:///../node_modules/hyperhtml/esm/objects/Intent.js","webpack:///../node_modules/@ungap/is-array/esm/index.js","webpack:///../node_modules/@ungap/create-content/esm/index.js","webpack:///../node_modules/disconnected/esm/index.js","webpack:///../node_modules/domconstants/esm/index.js","webpack:///../node_modules/@ungap/import-node/esm/index.js","webpack:///../node_modules/@ungap/trim/esm/index.js","webpack:///../node_modules/domsanitizer/esm/index.js","webpack:///../node_modules/domtagger/esm/walker.js","webpack:///../node_modules/domtagger/esm/index.js","webpack:///../node_modules/hyperhtml-style/esm/index.js","webpack:///../node_modules/hyperhtml-wire/esm/index.js","webpack:///../node_modules/hyperhtml/esm/shared/constants.js","webpack:///../node_modules/hyperhtml/esm/objects/Updates.js","webpack:///../node_modules/@ungap/template-literal/esm/index.js","webpack:///../node_modules/@ungap/template-tag-arguments/esm/index.js","webpack:///../node_modules/hyperhtml/esm/hyper/wire.js","webpack:///../node_modules/hyperhtml/esm/hyper/render.js","webpack:///../node_modules/hyperhtml/esm/index.js","webpack:///./utils/hyper-element/decorators.ts","webpack:///./utils/hyper-element/element.ts","webpack:///./utils/hyper-element/index.ts","webpack:///../node_modules/classnames/index.js","webpack:///./web-components/port-details.ts"],"names":["esm_self","WeakMap","id","Object","dP","defineProperty","hOP","hasOwnProperty","proto","prototype","delete","key","this","has","_","get","call","set","value","configurable","iterable","forEach","add","pair","Math","random","esm","essential_weakset_esm_self","WeakSet","object","essential_weakset_esm","essential_map_esm_self","Map","i","k","v","had","contains","splice","push","indexOf","essential_map_esm","append","parent","children","start","end","before","isSelect","selectedIndex","child","selected","insertBefore","eqeq","a","b","identity","O","moreNodes","moreStart","moreEnd","lessNodes","lessStart","lessEnd","compare","length","m","l","next","list","nextSibling","utils_remove","removeChild","range","ownerDocument","createRange","setStartBefore","setEndAfter","deleteContents","findK","ktr","j","lo","hi","mid","smartDiff","parentNode","futureNodes","futureStart","futureEnd","futureChanges","currentNodes","currentStart","currentEnd","currentChanges","currentLength","diff","live","currentIndex","applyDiff","rows","cols","d","r","c","pv","cv","pd","outer","Array","diffIdx","OND","minLen","link","tresh","keymap","idxInOld","newi","oldi","prev","ptr","HS","domdiff_esm","options","node","currentSame","futureSame","isReversed","custom_event_esm_self","CustomEvent","__p__","constructor","type","init","e","document","createEvent","initCustomEvent","bubbles","cancelable","detail","custom_event_esm","Component","lazyGetter","fn","secret","[object Object]","setValue","self","_wire$","apply","arguments","defineProperties","ELEMENT_NODE","nodeType","Intent_attributes","intents","keys","Intent_hasOwnProperty","Intent_length","toString","$","Intent","attributes","define","intent","callback","invoke","is_array_esm","isArray","create_content_esm","FRAGMENT","createHTML","create","html","template","innerHTML","content","childNodes","test","selector","RegExp","$1","querySelectorAll","markup","svg","firstChild","root","appendChild","element","createDocumentFragment","createElementNS","disconnected_esm","poly","Event","notObserving","observer","connected","disconnected","MutationObserver","changes","observe","subtree","childList","o_O","timer","records","reschedule","record","clearTimeout","setTimeout","addEventListener","event","addedNodes","removedNodes","target","dispatchAll","nodes","wsin","wsout","dispatchTarget","dispatchEvent","startObserving","import_node_esm","cloneNode","createTextNode","importNode","native","fragment","deep","clone","trim_esm","trim","String","replace","UID","toFixed","createElement","getAttribute","slice","meh","UIDC","COMMENT_NODE","TEXT_NODE","SHOULD_USE_TEXT_CONTENT","VOID_ELEMENTS","domsanitizer_esm","join","selfClosing","fullClosing","attrSeeker","attrReplacer","spaces","almostEverything","attrName","tagName","attrPartials","findAttributes","$0","$2","$3","replaceAttributes","walker_create","path","name","find","parseAttributes","holes","parts","cache","remove","array","attribute","realName","shift","toLowerCase","attr","removeAttribute","removeAttributeNode","nodeName","script","setAttributeNode","textContent","replaceChild","domtagger_esm","details","referenced","createDetails","updates","parsed","createInfo","transform","cleanContent","parse","childPath","concat","info","callbacks","len","any","text","values","Error","hyperhtml_style_esm","IS_NON_DIMENSIONAL","hyphen","original","style","setAttribute","getAttributeNode","update","ized","isSVG","oldType","oldValue","newValue","styleValue","cssText","setProperty","css","toStyle","hyperhtml_wire_esm","Wire","keepFirst","first","last","lastChild","valueOf","forceAppend","noFragment","n","OWNER_SVG_ELEMENT","componentType","wireType","asHTML","asNode","item","render","invokeAtDistance","placeholder","Promise","resolve","then","isPromise_ish","readOnly","Updates_text","Tagger","removeEventListener","owner","diffOptions","fastPath","anyContent","all","canDiff","isNoOp","templateLiteral","tl","UA","broken","defaultView","navigator","userAgent","FTS","propertyIsEnumerable","isFrozen","forever","foreverCache","wm","unique","TL","template_literal_esm","template_tag_arguments_esm","args","wires","wire_content","wire","tagger","wireContent","weakly","obj","hyper_wire","bewitched","hyper_render","wicked","__webpack_require__","__webpack_exports__","bind","hyper","context","esm_tagger","HTML","relate","Class","relation","w","p","for","component","createEntry","sm","handleEvent","ct","currentTarget","state","defaultState","dispatch","setState","source","setup","undefined","elementOrDescriptor","property","HTMLElement","_objectSpread","placement","kind","descriptor","Number","Boolean","hasAttribute","TypeError","_typeof","toggleAttribute","initializer","finisher","clazz","Set","observedAttributesInitializer","observedAttributes","_toConsumableArray","roots","firstRenderHandles","window","requestIdleCallback","cb","cancelIdleCallback","handle","HyperElement","shadowRootInit","attachShadow","_this","super","element_defineProperty","createRoot","_len","_key","result","addStyleElement","type_id","createWire","styleSheet","ShadowRoot","CSSStyleSheet","createStyleSheet","firstRender","connectedCallback","role","tabIndex","addTabIndex","_ref","adoptedStyleSheets","rules","replaceSync","addCSSStyleSheet","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","attributeInitializer","initializeAttribute","upgradeProperty","err","return","disconnectedCallback","attributeChangedCallback","Function","HTMLStyleElement","Reflect","deleteProperty","_ref5","mode","__WEBPACK_AMD_DEFINE_RESULT__","hasOwn","classNames","classes","arg","argType","inner","module","exports","default","PortDetails","_HyperElement","_initialize","_templateObject","open","_handleClick","_get","_getPrototypeOf","_handleKeyDown","passive","requestAnimationFrame","scrollIntoView","behavior","ev","_this2","toggle","button","_this3","shadowRoot","getElementById","code","click"],"mappings":"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","file":"js/0.ab176.js","sourcesContent":["/*! (c) Andrea Giammarchi - ISC */\nvar self = this || /* istanbul ignore next */ {};\ntry { self.WeakMap = WeakMap; }\ncatch (WeakMap) {\n  // this could be better but 90% of the time\n  // it's everything developers need as fallback\n  self.WeakMap = (function (id, Object) {'use strict';\n    var dP = Object.defineProperty;\n    var hOP = Object.hasOwnProperty;\n    var proto = WeakMap.prototype;\n    proto.delete = function (key) {\n      return this.has(key) && delete key[this._];\n    };\n    proto.get = function (key) {\n      return this.has(key) ? key[this._] : void 0;\n    };\n    proto.has = function (key) {\n      return hOP.call(key, this._);\n    };\n    proto.set = function (key, value) {\n      dP(key, this._, {configurable: true, value: value});\n      return this;\n    };\n    return WeakMap;\n    function WeakMap(iterable) {\n      dP(this, '_', {value: '_@ungap/weakmap' + id++});\n      if (iterable)\n        iterable.forEach(add, this);\n    }\n    function add(pair) {\n      this.set(pair[0], pair[1]);\n    }\n  }(Math.random(), Object));\n}\nexport default self.WeakMap;\n","/*! (c) Andrea Giammarchi - ISC */\nvar self = this || /* istanbul ignore next */ {};\ntry { self.WeakSet = WeakSet; }\ncatch (WeakSet) {\n  (function (id, dP) {\n    var proto = WeakSet.prototype;\n    proto.add = function (object) {\n      if (!this.has(object))\n        dP(object, this._, {value: true, configurable: true});\n      return this;\n    };\n    proto.has = function (object) {\n      return this.hasOwnProperty.call(object, this._);\n    };\n    proto.delete = function (object) {\n      return this.has(object) && delete object[this._];\n    };\n    self.WeakSet = WeakSet;\n    function WeakSet() {'use strict';\n      dP(this, '_', {value: '_@ungap/weakmap' + id++});\n    }\n  }(Math.random(), Object.defineProperty));\n}\nexport default self.WeakSet;\n","/*! (c) Andrea Giammarchi - ISC */\nvar self = this || /* istanbul ignore next */ {};\ntry { self.Map = Map; }\ncatch (Map) {\n  self.Map = function Map() {\n    var i = 0;\n    var k = [];\n    var v = [];\n    return {\n      delete: function (key) {\n        var had = contains(key);\n        if (had) {\n          k.splice(i, 1);\n          v.splice(i, 1);\n        }\n        return had;\n      },\n      get: function get(key) {\n        return contains(key) ? v[i] : void 0;\n      },\n      has: function has(key) {\n        return contains(key);\n      },\n      set: function set(key, value) {\n        v[contains(key) ? i : (k.push(key) - 1)] = value;\n        return this;\n      }\n    };\n    function contains(v) {\n      i = k.indexOf(v);\n      return -1 < i;\n    }\n  };\n}\nexport default self.Map;\n","import Map from '@ungap/essential-map';\n\nexport const append = (get, parent, children, start, end, before) => {\n  const isSelect = 'selectedIndex' in parent;\n  let selectedIndex = -1;\n  while (start < end) {\n    const child = get(children[start], 1);\n    if (isSelect && selectedIndex < 0 && child.selected)\n      selectedIndex = start;\n    parent.insertBefore(child, before);\n    start++;\n  }\n  if (isSelect && -1 < selectedIndex)\n    parent.selectedIndex = selectedIndex;\n};\n\nexport const eqeq = (a, b) => a == b;\n\nexport const identity = O => O;\n\nexport const indexOf = (\n  moreNodes,\n  moreStart,\n  moreEnd,\n  lessNodes,\n  lessStart,\n  lessEnd,\n  compare\n) => {\n  const length = lessEnd - lessStart;\n  /* istanbul ignore if */\n  if (length < 1)\n    return -1;\n  while ((moreEnd - moreStart) >= length) {\n    let m = moreStart;\n    let l = lessStart;\n    while (\n      m < moreEnd &&\n      l < lessEnd &&\n      compare(moreNodes[m], lessNodes[l])\n    ) {\n      m++;\n      l++;\n    }\n    if (l === lessEnd)\n      return moreStart;\n    moreStart = m + 1;\n  }\n  return -1;\n};\n\nexport const isReversed = (\n  futureNodes,\n  futureEnd,\n  currentNodes,\n  currentStart,\n  currentEnd,\n  compare\n) => {\n  while (\n    currentStart < currentEnd &&\n    compare(\n      currentNodes[currentStart],\n      futureNodes[futureEnd - 1]\n    )) {\n      currentStart++;\n      futureEnd--;\n    };\n  return futureEnd === 0;\n};\n\nexport const next = (get, list, i, length, before) => i < length ?\n              get(list[i], 0) :\n              (0 < i ?\n                get(list[i - 1], -0).nextSibling :\n                before);\n\nexport const remove = (get, parent, children, start, end) => {\n  if ((end - start) < 2)\n    parent.removeChild(get(children[start], -1));\n  else {\n    const range = parent.ownerDocument.createRange();\n    range.setStartBefore(get(children[start], -1));\n    range.setEndAfter(get(children[end - 1], -1));\n    range.deleteContents();\n  }\n};\n\n// - - - - - - - - - - - - - - - - - - -\n// diff related constants and utilities\n// - - - - - - - - - - - - - - - - - - -\n\nconst DELETION = -1;\nconst INSERTION = 1;\nconst SKIP = 0;\nconst SKIP_OND = 50;\n\nconst HS = (\n  futureNodes,\n  futureStart,\n  futureEnd,\n  futureChanges,\n  currentNodes,\n  currentStart,\n  currentEnd,\n  currentChanges\n) => {\n\n  let k = 0;\n  /* istanbul ignore next */\n  let minLen = futureChanges < currentChanges ? futureChanges : currentChanges;\n  const link = Array(minLen++);\n  const tresh = Array(minLen);\n  tresh[0] = -1;\n\n  for (let i = 1; i < minLen; i++)\n    tresh[i] = currentEnd;\n\n  const keymap = new Map;\n  for (let i = currentStart; i < currentEnd; i++)\n    keymap.set(currentNodes[i], i);\n\n  for (let i = futureStart; i < futureEnd; i++) {\n    const idxInOld = keymap.get(futureNodes[i]);\n    if (idxInOld != null) {\n      k = findK(tresh, minLen, idxInOld);\n      /* istanbul ignore else */\n      if (-1 < k) {\n        tresh[k] = idxInOld;\n        link[k] = {\n          newi: i,\n          oldi: idxInOld,\n          prev: link[k - 1]\n        };\n      }\n    }\n  }\n\n  k = --minLen;\n  --currentEnd;\n  while (tresh[k] > currentEnd) --k;\n\n  minLen = currentChanges + futureChanges - k;\n  const diff = Array(minLen);\n  let ptr = link[k];\n  --futureEnd;\n  while (ptr) {\n    const {newi, oldi} = ptr;\n    while (futureEnd > newi) {\n      diff[--minLen] = INSERTION;\n      --futureEnd;\n    }\n    while (currentEnd > oldi) {\n      diff[--minLen] = DELETION;\n      --currentEnd;\n    }\n    diff[--minLen] = SKIP;\n    --futureEnd;\n    --currentEnd;\n    ptr = ptr.prev;\n  }\n  while (futureEnd >= futureStart) {\n    diff[--minLen] = INSERTION;\n    --futureEnd;\n  }\n  while (currentEnd >= currentStart) {\n    diff[--minLen] = DELETION;\n    --currentEnd;\n  }\n  return diff;\n};\n\n// this is pretty much the same petit-dom code without the delete map part\n// https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L556-L561\nconst OND = (\n  futureNodes,\n  futureStart,\n  rows,\n  currentNodes,\n  currentStart,\n  cols,\n  compare\n) => {\n  const length = rows + cols;\n  const v = [];\n  let d, k, r, c, pv, cv, pd;\n  outer: for (d = 0; d <= length; d++) {\n    /* istanbul ignore if */\n    if (d > SKIP_OND)\n      return null;\n    pd = d - 1;\n    /* istanbul ignore next */\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || (k !== d && pv[pd + k - 1] < pv[pd + k + 1])) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n      r = c - k;\n      while (\n        c < cols &&\n        r < rows &&\n        compare(\n          currentNodes[currentStart + c],\n          futureNodes[futureStart + r]\n        )\n      ) {\n        c++;\n        r++;\n      }\n      if (c === cols && r === rows) {\n        break outer;\n      }\n      cv[d + k] = c;\n    }\n  }\n\n  const diff = Array(d / 2 + length / 2);\n  let diffIdx = diff.length - 1;\n  for (d = v.length - 1; d >= 0; d--) {\n    while (\n      c > 0 &&\n      r > 0 &&\n      compare(\n        currentNodes[currentStart + c - 1],\n        futureNodes[futureStart + r - 1]\n      )\n    ) {\n      // diagonal edge = equality\n      diff[diffIdx--] = SKIP;\n      c--;\n      r--;\n    }\n    if (!d)\n      break;\n    pd = d - 1;\n    /* istanbul ignore next */\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n    if (k === -d || (k !== d && pv[pd + k - 1] < pv[pd + k + 1])) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n    }\n  }\n  return diff;\n};\n\nconst applyDiff = (\n  diff,\n  get,\n  parentNode,\n  futureNodes,\n  futureStart,\n  currentNodes,\n  currentStart,\n  currentLength,\n  before\n) => {\n  const live = new Map;\n  const length = diff.length;\n  let currentIndex = currentStart;\n  let i = 0;\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        futureStart++;\n        currentIndex++;\n        break;\n      case INSERTION:\n        // TODO: bulk appends for sequential nodes\n        live.set(futureNodes[futureStart], 1);\n        append(\n          get,\n          parentNode,\n          futureNodes,\n          futureStart++,\n          futureStart,\n          currentIndex < currentLength ?\n            get(currentNodes[currentIndex], 0) :\n            before\n        );\n        break;\n      case DELETION:\n        currentIndex++;\n        break;\n    }\n  }\n  i = 0;\n  while (i < length) {\n    switch (diff[i++]) {\n      case SKIP:\n        currentStart++;\n        break;\n      case DELETION:\n        // TODO: bulk removes for sequential nodes\n        if (live.has(currentNodes[currentStart]))\n          currentStart++;\n        else\n          remove(\n            get,\n            parentNode,\n            currentNodes,\n            currentStart++,\n            currentStart\n          );\n        break;\n    }\n  }\n};\n\nconst findK = (ktr, length, j) => {\n  let lo = 1;\n  let hi = length;\n  while (lo < hi) {\n    const mid = ((lo + hi) / 2) >>> 0;\n    if (j < ktr[mid])\n      hi = mid;\n    else\n      lo = mid + 1;\n  }\n  return lo;\n}\n\nexport const smartDiff = (\n  get,\n  parentNode,\n  futureNodes,\n  futureStart,\n  futureEnd,\n  futureChanges,\n  currentNodes,\n  currentStart,\n  currentEnd,\n  currentChanges,\n  currentLength,\n  compare,\n  before\n) => {\n  applyDiff(\n    OND(\n      futureNodes,\n      futureStart,\n      futureChanges,\n      currentNodes,\n      currentStart,\n      currentChanges,\n      compare\n    ) ||\n    HS(\n      futureNodes,\n      futureStart,\n      futureEnd,\n      futureChanges,\n      currentNodes,\n      currentStart,\n      currentEnd,\n      currentChanges\n    ),\n    get,\n    parentNode,\n    futureNodes,\n    futureStart,\n    currentNodes,\n    currentStart,\n    currentLength,\n    before\n  );\n};\n","/*! (c) 2018 Andrea Giammarchi (ISC) */\n\nimport {\n  eqeq, identity, indexOf, isReversed, next,\n  append, remove,\n  smartDiff\n} from './utils.js';\n\nconst domdiff = (\n  parentNode,     // where changes happen\n  currentNodes,   // Array of current items/nodes\n  futureNodes,    // Array of future items/nodes\n  options         // optional object with one of the following properties\n                  //  before: domNode\n                  //  compare(generic, generic) => true if same generic\n                  //  node(generic) => Node\n) => {\n  if (!options)\n    options = {};\n\n  const compare = options.compare || eqeq;\n  const get = options.node || identity;\n  const before = options.before == null ? null : get(options.before, 0);\n\n  const currentLength = currentNodes.length;\n  let currentEnd = currentLength;\n  let currentStart = 0;\n\n  let futureEnd = futureNodes.length;\n  let futureStart = 0;\n\n  // common prefix\n  while (\n    currentStart < currentEnd &&\n    futureStart < futureEnd &&\n    compare(currentNodes[currentStart], futureNodes[futureStart])\n  ) {\n    currentStart++;\n    futureStart++;\n  }\n\n  // common suffix\n  while (\n    currentStart < currentEnd &&\n    futureStart < futureEnd &&\n    compare(currentNodes[currentEnd - 1], futureNodes[futureEnd - 1])\n  ) {\n    currentEnd--;\n    futureEnd--;\n  }\n\n  const currentSame = currentStart === currentEnd;\n  const futureSame = futureStart === futureEnd;\n\n  // same list\n  if (currentSame && futureSame)\n    return futureNodes;\n\n  // only stuff to add\n  if (currentSame && futureStart < futureEnd) {\n    append(\n      get,\n      parentNode,\n      futureNodes,\n      futureStart,\n      futureEnd,\n      next(get, currentNodes, currentStart, currentLength, before)\n    );\n    return futureNodes;\n  }\n\n  // only stuff to remove\n  if (futureSame && currentStart < currentEnd) {\n    remove(\n      get,\n      parentNode,\n      currentNodes,\n      currentStart,\n      currentEnd\n    );\n    return futureNodes;\n  }\n\n  const currentChanges = currentEnd - currentStart;\n  const futureChanges = futureEnd - futureStart;\n  let i = -1;\n\n  // 2 simple indels: the shortest sequence is a subsequence of the longest\n  if (currentChanges < futureChanges) {\n    i = indexOf(\n      futureNodes,\n      futureStart,\n      futureEnd,\n      currentNodes,\n      currentStart,\n      currentEnd,\n      compare\n    );\n    // inner diff\n    if (-1 < i) {\n      append(\n        get,\n        parentNode,\n        futureNodes,\n        futureStart,\n        i,\n        get(currentNodes[currentStart], 0)\n      );\n      append(\n        get,\n        parentNode,\n        futureNodes,\n        i + currentChanges,\n        futureEnd,\n        next(get, currentNodes, currentEnd, currentLength, before)\n      );\n      return futureNodes;\n    }\n  }\n  /* istanbul ignore else */\n  else if (futureChanges < currentChanges) {\n    i = indexOf(\n      currentNodes,\n      currentStart,\n      currentEnd,\n      futureNodes,\n      futureStart,\n      futureEnd,\n      compare\n    );\n    // outer diff\n    if (-1 < i) {\n      remove(\n        get,\n        parentNode,\n        currentNodes,\n        currentStart,\n        i\n      );\n      remove(\n        get,\n        parentNode,\n        currentNodes,\n        i + futureChanges,\n        currentEnd\n      );\n      return futureNodes;\n    }\n  }\n\n  // common case with one replacement for many nodes\n  // or many nodes replaced for a single one\n  /* istanbul ignore else */\n  if ((currentChanges < 2 || futureChanges < 2)) {\n    append(\n      get,\n      parentNode,\n      futureNodes,\n      futureStart,\n      futureEnd,\n      get(currentNodes[currentStart], 0)\n    );\n    remove(\n      get,\n      parentNode,\n      currentNodes,\n      currentStart,\n      currentEnd\n    );\n    return futureNodes;\n  }\n\n  // the half match diff part has been skipped in petit-dom\n  // https://github.com/yelouafi/petit-dom/blob/bd6f5c919b5ae5297be01612c524c40be45f14a7/src/vdom.js#L391-L397\n  // accordingly, I think it's safe to skip in here too\n  // if one day it'll come out like the speediest thing ever to do\n  // then I might add it in here too\n\n  // Extra: before going too fancy, what about reversed lists ?\n  //        This should bail out pretty quickly if that's not the case.\n  if (\n    currentChanges === futureChanges &&\n    isReversed(\n      futureNodes,\n      futureEnd,\n      currentNodes,\n      currentStart,\n      currentEnd,\n      compare\n    )\n  ) {\n    append(\n      get,\n      parentNode,\n      futureNodes,\n      futureStart,\n      futureEnd,\n      next(get, currentNodes, currentEnd, currentLength, before)\n    );\n    return futureNodes;\n  }\n\n  // last resort through a smart diff\n  smartDiff(\n    get,\n    parentNode,\n    futureNodes,\n    futureStart,\n    futureEnd,\n    futureChanges,\n    currentNodes,\n    currentStart,\n    currentEnd,\n    currentChanges,\n    currentLength,\n    compare,\n    before\n  );\n\n  return futureNodes;\n};\n\nexport default domdiff;\n","/*! (c) Andrea Giammarchi - ISC */\nvar self = this || /* istanbul ignore next */ {};\nself.CustomEvent = typeof CustomEvent === 'function' ?\n  CustomEvent :\n  (function (__p__) {\n    CustomEvent[__p__] = new CustomEvent('').constructor[__p__];\n    return CustomEvent;\n    function CustomEvent(type, init) {\n      if (!init) init = {};\n      var e = document.createEvent('CustomEvent');\n      e.initCustomEvent(type, !!init.bubbles, !!init.cancelable, init.detail);\n      return e;\n    }\n  }('prototype'));\nexport default self.CustomEvent;\n","import CustomEvent from '@ungap/custom-event';\nimport Map from '@ungap/essential-map';\nimport WeakMap from '@ungap/weakmap';\n\n// hyperHTML.Component is a very basic class\n// able to create Custom Elements like components\n// including the ability to listen to connect/disconnect\n// events via onconnect/ondisconnect attributes\n// Components can be created imperatively or declaratively.\n// The main difference is that declared components\n// will not automatically render on setState(...)\n// to simplify state handling on render.\nexport default function Component() {\n  return this; // this is needed in Edge !!!\n}\n\n// Component is lazily setup because it needs\n// wire mechanism as lazy content\nexport function setup(content) {\n  // there are various weakly referenced variables in here\n  // and mostly are to use Component.for(...) static method.\n  const children = new WeakMap;\n  const create = Object.create;\n  const createEntry = (wm, id, component) => {\n    wm.set(id, component);\n    return component;\n  };\n  const get = (Class, info, context, id) => {\n    const relation = info.get(Class) || relate(Class, info);\n    switch (typeof id) {\n      case 'object':\n      case 'function':\n        const wm = relation.w || (relation.w = new WeakMap);\n        return wm.get(id) || createEntry(wm, id, new Class(context));\n      default:\n        const sm = relation.p || (relation.p = create(null));\n        return sm[id] || (sm[id] = new Class(context));\n    }\n  };\n  const relate = (Class, info) => {\n    const relation = {w: null, p: null};\n    info.set(Class, relation);\n    return relation;\n  };\n  const set = context => {\n    const info = new Map;\n    children.set(context, info);\n    return info;\n  };\n  // The Component Class\n  Object.defineProperties(\n    Component,\n    {\n      // Component.for(context[, id]) is a convenient way\n      // to automatically relate data/context to children components\n      // If not created yet, the new Component(context) is weakly stored\n      // and after that same instance would always be returned.\n      for: {\n        configurable: true,\n        value(context, id) {\n          return get(\n            this,\n            children.get(context) || set(context),\n            context,\n            id == null ?\n              'default' : id\n          );\n        }\n      }\n    }\n  );\n  Object.defineProperties(\n    Component.prototype,\n    {\n      // all events are handled with the component as context\n      handleEvent: {value(e) {\n        const ct = e.currentTarget;\n        this[\n          ('getAttribute' in ct && ct.getAttribute('data-call')) ||\n          ('on' + e.type)\n        ](e);\n      }},\n      // components will lazily define html or svg properties\n      // as soon as these are invoked within the .render() method\n      // Such render() method is not provided by the base class\n      // but it must be available through the Component extend.\n      // Declared components could implement a\n      // render(props) method too and use props as needed.\n      html: lazyGetter('html', content),\n      svg: lazyGetter('svg', content),\n      // the state is a very basic/simple mechanism inspired by Preact\n      state: lazyGetter('state', function () { return this.defaultState; }),\n      // it is possible to define a default state that'd be always an object otherwise\n      defaultState: {get() { return {}; }},\n      // dispatch a bubbling, cancelable, custom event\n      // through the first known/available node\n      dispatch: {value(type, detail) {\n        const {_wire$} = this;\n        if (_wire$) {\n          const event = new CustomEvent(type, {\n            bubbles: true,\n            cancelable: true,\n            detail\n          });\n          event.component = this;\n          return (_wire$.dispatchEvent ?\n                    _wire$ :\n                    _wire$.firstChild\n                  ).dispatchEvent(event);\n        }\n        return false;\n      }},\n      // setting some property state through a new object\n      // or a callback, triggers also automatically a render\n      // unless explicitly specified to not do so (render === false)\n      setState: {value(state, render) {\n        const target = this.state;\n        const source = typeof state === 'function' ? state.call(this, target) : state;\n        for (const key in source) target[key] = source[key];\n        if (render !== false)\n          this.render();\n        return this;\n      }}\n    }\n  );\n}\n\n// instead of a secret key I could've used a WeakMap\n// However, attaching a property directly will result\n// into better performance with thousands of components\n// hanging around, and less memory pressure caused by the WeakMap\nconst lazyGetter = (type, fn) => {\n  const secret = '_' + type + '$';\n  return {\n    get() {\n      return this[secret] || setValue(this, secret, fn.call(this, type));\n    },\n    set(value) {\n      setValue(this, secret, value);\n    }\n  };\n};\n\n// shortcut to set value on get or set(value)\nconst setValue = (self, secret, value) =>\n  Object.defineProperty(self, secret, {\n    configurable: true,\n    value: typeof value === 'function' ?\n      function () {\n        return (self._wire$ = value.apply(this, arguments));\n      } :\n      value\n  })[secret]\n;\n\nObject.defineProperties(\n  Component.prototype,\n  {\n    // used to distinguish better than instanceof\n    ELEMENT_NODE: {value: 1},\n    nodeType: {value: -1}\n  }\n);\n","const attributes = {};\nconst intents = {};\nconst keys = [];\nconst hasOwnProperty = intents.hasOwnProperty;\n\nlet length = 0;\n\nexport default {\n\n  // used to invoke right away hyper:attributes\n  attributes,\n\n  // hyperHTML.define('intent', (object, update) => {...})\n  // can be used to define a third parts update mechanism\n  // when every other known mechanism failed.\n  // hyper.define('user', info => info.name);\n  // hyper(node)`<p>${{user}}</p>`;\n  define: (intent, callback) => {\n    if (intent.indexOf('-') < 0) {\n      if (!(intent in intents)) {\n        length = keys.push(intent);\n      }\n      intents[intent] = callback;\n    } else {\n      attributes[intent] = callback;\n    }\n  },\n\n  // this method is used internally as last resort\n  // to retrieve a value out of an object\n  invoke: (object, callback) => {\n    for (let i = 0; i < length; i++) {\n      let key = keys[i];\n      if (hasOwnProperty.call(object, key)) {\n        return intents[key](object[key], callback);\n      }\n    }\n  }\n};\n","var isArray = Array.isArray || (function (toString) {\n  var $ = toString.call([]);\n  return function isArray(object) {\n    return toString.call(object) === $;\n  };\n}({}.toString));\nexport default isArray;\n","/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {'use strict';\n  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\nexport default createContent;\n","/*! (c) Andrea Giammarchi */\nfunction disconnected(poly) {'use strict';\n  var Event = poly.Event;\n  var WeakSet = poly.WeakSet;\n  var notObserving = true;\n  var observer = null;\n  return function observe(node) {\n    if (notObserving) {\n      notObserving = !notObserving;\n      observer = new WeakSet;\n      startObserving(node.ownerDocument);\n    }\n    observer.add(node);\n    return node;\n  };\n  function startObserving(document) {\n    var connected = new WeakSet;\n    var disconnected = new WeakSet;\n    try {\n      (new MutationObserver(changes)).observe(\n        document,\n        {subtree: true, childList: true}\n      );\n    }\n    catch(o_O) {\n      var timer = 0;\n      var records = [];\n      var reschedule = function (record) {\n        records.push(record);\n        clearTimeout(timer);\n        timer = setTimeout(\n          function () {\n            changes(records.splice(timer = 0, records.length));\n          },\n          0\n        );\n      };\n      document.addEventListener(\n        'DOMNodeRemoved',\n        function (event) {\n          reschedule({addedNodes: [], removedNodes: [event.target]});\n        },\n        true\n      );\n      document.addEventListener(\n        'DOMNodeInserted',\n        function (event) {\n          reschedule({addedNodes: [event.target], removedNodes: []});\n        },\n        true\n      );\n    }\n    function changes(records) {\n      for (var\n        record,\n        length = records.length,\n        i = 0; i < length; i++\n      ) {\n        record = records[i];\n        dispatchAll(record.removedNodes, 'disconnected', disconnected, connected);\n        dispatchAll(record.addedNodes, 'connected', connected, disconnected);\n      }\n    }\n    function dispatchAll(nodes, type, wsin, wsout) {\n      for (var\n        node,\n        event = new Event(type),\n        length = nodes.length,\n        i = 0; i < length;\n        (node = nodes[i++]).nodeType === 1 &&\n        dispatchTarget(node, event, type, wsin, wsout)\n      );\n    }\n    function dispatchTarget(node, event, type, wsin, wsout) {\n      if (observer.has(node) && !wsin.has(node)) {\n        wsout.delete(node);\n        wsin.add(node);\n        node.dispatchEvent(event);\n        /*\n        // The event is not bubbling (perf reason: should it?),\n        // hence there's no way to know if\n        // stop/Immediate/Propagation() was called.\n        // Should DOM Level 0 work at all?\n        // I say it's a YAGNI case for the time being,\n        // and easy to implement in user-land.\n        if (!event.cancelBubble) {\n          var fn = node['on' + type];\n          if (fn)\n            fn.call(node, event);\n        }\n        */\n      }\n      for (var\n        // apparently is node.children || IE11 ... ^_^;;\n        // https://github.com/WebReflection/disconnected/issues/1\n        children = node.children || [],\n        length = children.length,\n        i = 0; i < length;\n        dispatchTarget(children[i++], event, type, wsin, wsout)\n      );\n    }\n  }\n}\nexport default disconnected;\n","/*! (c) Andrea Giammarchi - ISC */\n\n// Custom\nvar UID = '-' + Math.random().toFixed(6) + '%';\n//                           Edge issue!\n\nvar UID_IE = false;\n\ntry {\n  if (!(function (template, content, tabindex) {\n    return content in template && (\n      (template.innerHTML = '<p ' + tabindex + '=\"' + UID + '\"></p>'),\n      template[content].childNodes[0].getAttribute(tabindex) == UID\n    );\n  }(document.createElement('template'), 'content', 'tabindex'))) {\n    UID = '_dt: ' + UID.slice(1, -1) + ';';\n    UID_IE = true;\n  }\n} catch(meh) {}\n\nvar UIDC = '<!--' + UID + '-->';\n\n// DOM\nvar COMMENT_NODE = 8;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\n\nvar SHOULD_USE_TEXT_CONTENT = /^(?:style|textarea)$/i;\nvar VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n\nexport {\n  UID, UIDC, UID_IE,\n  COMMENT_NODE,\n  DOCUMENT_FRAGMENT_NODE,\n  ELEMENT_NODE,\n  TEXT_NODE,\n  SHOULD_USE_TEXT_CONTENT,\n  VOID_ELEMENTS\n};\n","/*! (c) Andrea Giammarchi - ISC */\nvar importNode = (function (\n  document,\n  appendChild,\n  cloneNode,\n  createTextNode,\n  importNode\n) {\n  var native = importNode in document;\n  // IE 11 has problems with cloning templates:\n  // it \"forgets\" empty childNodes. This feature-detects that.\n  var fragment = document.createDocumentFragment();\n  fragment[appendChild](document[createTextNode]('g'));\n  fragment[appendChild](document[createTextNode](''));\n  var content = native ?\n    document[importNode](fragment, true) :\n    fragment[cloneNode](true);\n  return content.childNodes.length < 2 ?\n    function importNode(node, deep) {\n      var clone = node[cloneNode]();\n      for (var\n        childNodes = node.childNodes || [],\n        length = childNodes.length,\n        i = 0; deep && i < length; i++\n      ) {\n        clone[appendChild](importNode(childNodes[i], deep));\n      }\n      return clone;\n    } :\n    (native ?\n      document[importNode] :\n      function (node, deep) {\n        return node[cloneNode](!!deep);\n      }\n    );\n}(\n  document,\n  'appendChild',\n  'cloneNode',\n  'createTextNode',\n  'importNode'\n));\nexport default importNode;\n","var trim = ''.trim || function () {\n  return String(this).replace(/^\\s+|\\s+/g, '');\n};\nexport default trim;\n","/*! (c) Andrea Giammarchi - ISC */\n\nimport {UID, UIDC, VOID_ELEMENTS} from 'domconstants';\n\nexport default function (template) {\n  return template.join(UIDC)\n          .replace(selfClosing, fullClosing)\n          .replace(attrSeeker, attrReplacer);\n}\n\nvar spaces = ' \\\\f\\\\n\\\\r\\\\t';\nvar almostEverything = '[^' + spaces + '\\\\/>\"\\'=]+';\nvar attrName = '[' + spaces + ']+' + almostEverything;\nvar tagName = '<([A-Za-z]+[A-Za-z0-9:_-]*)((?:';\nvar attrPartials = '(?:\\\\s*=\\\\s*(?:\\'[^\\']*?\\'|\"[^\"]*?\"|<[^>]*?>|' + almostEverything.replace('\\\\/', '') + '))?)';\n\nvar attrSeeker = new RegExp(tagName + attrName + attrPartials + '+)([' + spaces + ']*/?>)', 'g');\nvar selfClosing = new RegExp(tagName + attrName + attrPartials + '*)([' + spaces + ']*/>)', 'g');\nvar findAttributes = new RegExp('(' + attrName + '\\\\s*=\\\\s*)([\\'\"]?)' + UIDC + '\\\\2', 'gi');\n\nfunction attrReplacer($0, $1, $2, $3) {\n  return '<' + $1 + $2.replace(findAttributes, replaceAttributes) + $3;\n}\n\nfunction replaceAttributes($0, $1, $2) {\n  return $1 + ($2 || '\"') + UID + ($2 || '\"');\n}\n\nfunction fullClosing($0, $1, $2) {\n  return VOID_ELEMENTS.test($1) ? $0 : ('<' + $1 + $2 + '></' + $1 + '>');\n}\n","import Map from '@ungap/essential-map';\nimport trim from '@ungap/trim';\n\nimport {\n  UID, UIDC,\n  COMMENT_NODE,\n  ELEMENT_NODE,\n  SHOULD_USE_TEXT_CONTENT,\n  TEXT_NODE\n} from 'domconstants';\n\nexport {find, parse};\n\nfunction create(type, node, path, name) {\n  return {name: name, node: node, path: path, type: type};\n}\n\nfunction find(node, path) {\n  var length = path.length;\n  var i = 0;\n  while (i < length)\n    node = node.childNodes[path[i++]];\n  return node;\n}\n\nfunction parse(node, holes, parts, path) {\n  var childNodes = node.childNodes;\n  var length = childNodes.length;\n  var i = 0;\n  while (i < length) {\n    var child = childNodes[i];\n    switch (child.nodeType) {\n      case ELEMENT_NODE:\n        var childPath = path.concat(i);\n        parseAttributes(child, holes, parts, childPath);\n        parse(child, holes, parts, childPath);\n        break;\n      case COMMENT_NODE:\n        var textContent = child.textContent;\n        if (textContent === UID) {\n          parts.shift();\n          holes.push(\n            // basicHTML or other non standard engines\n            // might end up having comments in nodes\n            // where they shouldn't, hence this check.\n            SHOULD_USE_TEXT_CONTENT.test(node.nodeName) ?\n              create('text', node, path) :\n              create('any', child, path.concat(i))\n          );\n        } else {\n          switch (textContent.slice(0, 2)) {\n            case '/*':\n              if (textContent.slice(-2) !== '*/')\n                break;\n            case '\\uD83D\\uDC7B': // ghost\n              node.removeChild(child);\n              i--;\n              length--;\n          }\n        }\n        break;\n      case TEXT_NODE:\n        // the following ignore is actually covered by browsers\n        // only basicHTML ends up on previous COMMENT_NODE case\n        // instead of TEXT_NODE because it knows nothing about\n        // special style or textarea behavior\n        /* istanbul ignore if */\n        if (\n          SHOULD_USE_TEXT_CONTENT.test(node.nodeName) &&\n          trim.call(child.textContent) === UIDC\n        ) {\n          parts.shift();\n          holes.push(create('text', node, path));\n        }\n        break;\n    }\n    i++;\n  }\n}\n\nfunction parseAttributes(node, holes, parts, path) {\n  var cache = new Map;\n  var attributes = node.attributes;\n  var remove = [];\n  var array = remove.slice.call(attributes, 0);\n  var length = array.length;\n  var i = 0;\n  while (i < length) {\n    var attribute = array[i++];\n    if (attribute.value === UID) {\n      var name = attribute.name;\n      // the following ignore is covered by IE\n      // and the IE9 double viewBox test\n      /* istanbul ignore else */\n      if (!cache.has(name)) {\n        var realName = parts.shift().replace(/^(?:|[\\S\\s]*?\\s)(\\S+?)\\s*=\\s*['\"]?$/, '$1');\n        var value = attributes[realName] ||\n                      // the following ignore is covered by browsers\n                      // while basicHTML is already case-sensitive\n                      /* istanbul ignore next */\n                      attributes[realName.toLowerCase()];\n        cache.set(name, value);\n        holes.push(create('attr', value, path, realName));\n      }\n      remove.push(attribute);\n    }\n  }\n  length = remove.length;\n  i = 0;\n  while (i < length) {\n    // Edge HTML bug #16878726\n    var attr = remove[i++];\n    if (/^id$/i.test(attr.name))\n      node.removeAttribute(attr.name);\n    // standard browsers would work just fine here\n    else\n      node.removeAttributeNode(attr);\n  }\n\n  // This is a very specific Firefox/Safari issue\n  // but since it should be a not so common pattern,\n  // it's probably worth patching regardless.\n  // Basically, scripts created through strings are death.\n  // You need to create fresh new scripts instead.\n  // TODO: is there any other node that needs such nonsense?\n  var nodeName = node.nodeName;\n  if (/^script$/i.test(nodeName)) {\n    // this used to be like that\n    // var script = createElement(node, nodeName);\n    // then Edge arrived and decided that scripts created\n    // through template documents aren't worth executing\n    // so it became this ... hopefully it won't hurt in the wild\n    var script = document.createElement(nodeName);\n    length = attributes.length;\n    i = 0;\n    while (i < length)\n      script.setAttributeNode(attributes[i++].cloneNode(true));\n    script.textContent = node.textContent;\n    node.parentNode.replaceChild(script, node);\n  }\n}\n","// globals\nimport WeakMap from '@ungap/weakmap';\n\n// utils\nimport createContent from '@ungap/create-content';\nimport importNode from '@ungap/import-node';\nimport trim from '@ungap/trim';\nimport sanitize from 'domsanitizer';\n\n// local\nimport {find, parse} from './walker.js';\n\n// the domtagger \nexport default domtagger;\n\nvar parsed = new WeakMap;\nvar referenced = new WeakMap;\n\nfunction createInfo(options, template) {\n  var markup = sanitize(template);\n  var transform = options.transform;\n  if (transform)\n    markup = transform(markup);\n  var content = createContent(markup, options.type);\n  cleanContent(content);\n  var holes = [];\n  parse(content, holes, template.slice(0), []);\n  var info = {\n    content: content,\n    updates: function (content) {\n      var callbacks = [];\n      var len = holes.length;\n      var i = 0;\n      while (i < len) {\n        var info = holes[i++];\n        var node = find(content, info.path);\n        switch (info.type) {\n          case 'any':\n            callbacks.push(options.any(node, []));\n            break;\n          case 'attr':\n            callbacks.push(options.attribute(node, info.name, info.node));\n            break;\n          case 'text':\n            callbacks.push(options.text(node));\n            node.textContent = '';\n            break;\n        }\n      }\n      return function () {\n        var length = arguments.length;\n        var values = length - 1;\n        var i = 1;\n        if (len !== values) {\n          throw new Error(\n            values + ' values instead of ' + len + '\\n' +\n            template.join(', ')\n          );\n        }\n        while (i < length)\n          callbacks[i - 1](arguments[i++]);\n        return content;\n      };\n    }\n  };\n  parsed.set(template, info);\n  return info;\n}\n\nfunction createDetails(options, template) {\n  var info = parsed.get(template) || createInfo(options, template);\n  var content = importNode.call(document, info.content, true);\n  var details = {\n    content: content,\n    template: template,\n    updates: info.updates(content)\n  };\n  referenced.set(options, details);\n  return details;\n}\n\nfunction domtagger(options) {\n  return function (template) {\n    var details = referenced.get(options);\n    if (details == null || details.template !== template)\n      details = createDetails(options, template);\n    details.updates.apply(null, arguments);\n    return details.content;\n  };\n}\n\nfunction cleanContent(fragment) {\n  var childNodes = fragment.childNodes;\n  var i = childNodes.length;\n  while (i--) {\n    var child = childNodes[i];\n    if (\n      child.nodeType !== 1 &&\n      trim.call(child.textContent).length === 0\n    ) {\n      fragment.removeChild(child);\n    }\n  }\n}\n","/*! (c) Andrea Giammarchi - ISC */\nvar hyperStyle = (function (){'use strict';\n  // from https://github.com/developit/preact/blob/33fc697ac11762a1cb6e71e9847670d047af7ce5/src/varants.js\n  var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n  var hyphen = /([^A-Z])([A-Z]+)/g;\n  return function hyperStyle(node, original) {\n    return 'ownerSVGElement' in node ? svg(node, original) : update(node.style, false);\n  };\n  function ized($0, $1, $2) {\n    return $1 + '-' + $2.toLowerCase();\n  }\n  function svg(node, original) {\n    var style;\n    if (original)\n      style = original.cloneNode(true);\n    else {\n      node.setAttribute('style', '--hyper:style;');\n      style = node.getAttributeNode('style');\n    }\n    style.value = '';\n    node.setAttributeNode(style);\n    return update(style, true);\n  }\n  function toStyle(object) {\n    var key, css = [];\n    for (key in object)\n      css.push(key.replace(hyphen, ized), ':', object[key], ';');\n    return css.join('');\n  }\n  function update(style, isSVG) {\n    var oldType, oldValue;\n    return function (newValue) {\n      var info, key, styleValue, value;\n      switch (typeof newValue) {\n        case 'object':\n          if (newValue) {\n            if (oldType === 'object') {\n              if (!isSVG) {\n                if (oldValue !== newValue) {\n                  for (key in oldValue) {\n                    if (!(key in newValue)) {\n                      style[key] = '';\n                    }\n                  }\n                }\n              }\n            } else {\n              if (isSVG)\n                style.value = '';\n              else\n                style.cssText = '';\n            }\n            info = isSVG ? {} : style;\n            for (key in newValue) {\n              value = newValue[key];\n              styleValue = typeof value === 'number' &&\n                                  !IS_NON_DIMENSIONAL.test(key) ?\n                                  (value + 'px') : value;\n              if (!isSVG && /^--/.test(key))\n                info.setProperty(key, styleValue);\n              else\n                info[key] = styleValue;\n            }\n            oldType = 'object';\n            if (isSVG)\n              style.value = toStyle((oldValue = info));\n            else\n              oldValue = newValue;\n            break;\n          }\n        default:\n          if (oldValue != newValue) {\n            oldType = 'string';\n            oldValue = newValue;\n            if (isSVG)\n              style.value = newValue || '';\n            else\n              style.cssText = newValue || '';\n          }\n          break;\n      }\n    };\n  }\n}());\nexport default hyperStyle;\n","/*! (c) Andrea Giammarchi - ISC */\nvar Wire = (function (slice, proto) {\n\n  proto = Wire.prototype;\n\n  proto.ELEMENT_NODE = 1;\n  proto.nodeType = 111;\n\n  proto.remove = function (keepFirst) {\n    var childNodes = this.childNodes;\n    var first = this.firstChild;\n    var last = this.lastChild;\n    this._ = null;\n    if (keepFirst && childNodes.length === 2) {\n      last.parentNode.removeChild(last);\n    } else {\n      var range = this.ownerDocument.createRange();\n      range.setStartBefore(keepFirst ? childNodes[1] : first);\n      range.setEndAfter(last);\n      range.deleteContents();\n    }\n    return first;\n  };\n\n  proto.valueOf = function (forceAppend) {\n    var fragment = this._;\n    var noFragment = fragment == null;\n    if (noFragment)\n      fragment = (this._ = this.ownerDocument.createDocumentFragment());\n    if (noFragment || forceAppend) {\n      for (var n = this.childNodes, i = 0, l = n.length; i < l; i++)\n        fragment.appendChild(n[i]);\n    }\n    return fragment;\n  };\n\n  return Wire;\n\n  function Wire(childNodes) {\n    var nodes = (this.childNodes = slice.call(childNodes, 0));\n    this.firstChild = nodes[0];\n    this.lastChild = nodes[nodes.length - 1];\n    this.ownerDocument = nodes[0].ownerDocument;\n    this._ = null;\n  }\n\n}([].slice));\nexport default Wire;\n","// Node.CONSTANTS\n// 'cause some engine has no global Node defined\n// (i.e. Node, NativeScript, basicHTML ... )\nexport const ELEMENT_NODE = 1;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n\n// SVG related constants\nexport const OWNER_SVG_ELEMENT = 'ownerSVGElement';\n\n// Custom Elements / MutationObserver constants\nexport const CONNECTED = 'connected';\nexport const DISCONNECTED = 'dis' + CONNECTED;\n","import CustomEvent from '@ungap/custom-event';\nimport WeakSet from '@ungap/essential-weakset';\nimport isArray from '@ungap/is-array';\nimport createContent from '@ungap/create-content';\n\nimport disconnected from 'disconnected';\nimport domdiff from 'domdiff';\nimport domtagger from 'domtagger';\nimport hyperStyle from 'hyperhtml-style';\nimport Wire from 'hyperhtml-wire';\n\nimport {\n  CONNECTED, DISCONNECTED,\n  DOCUMENT_FRAGMENT_NODE,\n  OWNER_SVG_ELEMENT\n} from '../shared/constants.js';\n\nimport Component from '../classes/Component.js';\nimport Intent from './Intent.js';\n\nconst componentType = Component.prototype.nodeType;\nconst wireType = Wire.prototype.nodeType;\n\nconst observe = disconnected({Event: CustomEvent, WeakSet});\n\nexport {Tagger, observe};\n\n// returns an intent to explicitly inject content as html\nconst asHTML = html => ({html});\n\n// returns nodes from wires and components\nconst asNode = (item, i) => {\n  switch (item.nodeType) {\n    case wireType:\n      // in the Wire case, the content can be\n      // removed, post-pended, inserted, or pre-pended and\n      // all these cases are handled by domdiff already\n      /* istanbul ignore next */\n      return (1 / i) < 0 ?\n        (i ? item.remove(true) : item.lastChild) :\n        (i ? item.valueOf(true) : item.firstChild);\n    case componentType:\n      return asNode(item.render(), i);\n    default:\n      return item;\n  }\n}\n\n// returns true if domdiff can handle the value\nconst canDiff = value => 'ELEMENT_NODE' in value;\n\n// when a Promise is used as interpolation value\n// its result must be parsed once resolved.\n// This callback is in charge of understanding what to do\n// with a returned value once the promise is resolved.\nconst invokeAtDistance = (value, callback) => {\n  callback(value.placeholder);\n  if ('text' in value) {\n    Promise.resolve(value.text).then(String).then(callback);\n  } else if ('any' in value) {\n    Promise.resolve(value.any).then(callback);\n  } else if ('html' in value) {\n    Promise.resolve(value.html).then(asHTML).then(callback);\n  } else {\n    Promise.resolve(Intent.invoke(value, callback)).then(callback);\n  }\n};\n\n// quick and dirty way to check for Promise/ish values\nconst isPromise_ish = value => value != null && 'then' in value;\n\n// list of attributes that should not be directly assigned\nconst readOnly = /^(?:form|list)$/i;\n\n// reused every slice time\nconst slice = [].slice;\n\n// simplifies text node creation\nconst text = (node, text) => node.ownerDocument.createTextNode(text);\n\nfunction Tagger(type) {\n  this.type = type;\n  return domtagger(this);\n}\n\nTagger.prototype = {\n\n  // there are four kind of attributes, and related behavior:\n  //  * events, with a name starting with `on`, to add/remove event listeners\n  //  * special, with a name present in their inherited prototype, accessed directly\n  //  * regular, accessed through get/setAttribute standard DOM methods\n  //  * style, the only regular attribute that also accepts an object as value\n  //    so that you can style=${{width: 120}}. In this case, the behavior has been\n  //    fully inspired by Preact library and its simplicity.\n  attribute(node, name, original) {\n    const isSVG = OWNER_SVG_ELEMENT in node;\n    let oldValue;\n    // if the attribute is the style one\n    // handle it differently from others\n    if (name === 'style')\n      return hyperStyle(node, original, isSVG);\n    // the name is an event one,\n    // add/remove event listeners accordingly\n    else if (/^on/.test(name)) {\n      let type = name.slice(2);\n      if (type === CONNECTED || type === DISCONNECTED) {\n        observe(node);\n      }\n      else if (name.toLowerCase()\n        in node) {\n        type = type.toLowerCase();\n      }\n      return newValue => {\n        if (oldValue !== newValue) {\n          if (oldValue)\n            node.removeEventListener(type, oldValue, false);\n          oldValue = newValue;\n          if (newValue)\n            node.addEventListener(type, newValue, false);\n        }\n      };\n    }\n    // the attribute is special ('value' in input)\n    // and it's not SVG *or* the name is exactly data,\n    // in this case assign the value directly\n    else if (\n      name === 'data' ||\n      (!isSVG && name in node && !readOnly.test(name))\n    ) {\n      return newValue => {\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (node[name] !== newValue && newValue == null) {\n            // cleanup on null to avoid silly IE/Edge bug\n            node[name] = '';\n            node.removeAttribute(name);\n          }\n          else\n            node[name] = newValue;\n        }\n      };\n    }\n    else if (name in Intent.attributes) {\n      oldValue;\n      return any => {\n        const newValue = Intent.attributes[name](node, any);\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (newValue == null)\n            node.removeAttribute(name);\n          else\n            node.setAttribute(name, newValue);\n        }\n      };\n    }\n    // in every other case, use the attribute node as it is\n    // update only the value, set it as node only when/if needed\n    else {\n      let owner = false;\n      const attribute = original.cloneNode(true);\n      return newValue => {\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (attribute.value !== newValue) {\n            if (newValue == null) {\n              if (owner) {\n                owner = false;\n                node.removeAttributeNode(attribute);\n              }\n              attribute.value = newValue;\n            } else {\n              attribute.value = newValue;\n              if (!owner) {\n                owner = true;\n                node.setAttributeNode(attribute);\n              }\n            }\n          }\n        }\n      };\n    }\n  },\n\n  // in a hyper(node)`<div>${content}</div>` case\n  // everything could happen:\n  //  * it's a JS primitive, stored as text\n  //  * it's null or undefined, the node should be cleaned\n  //  * it's a component, update the content by rendering it\n  //  * it's a promise, update the content once resolved\n  //  * it's an explicit intent, perform the desired operation\n  //  * it's an Array, resolve all values if Promises and/or\n  //    update the node with the resulting list of content\n  any(node, childNodes) {\n    const diffOptions = {node: asNode, before: node};\n    const nodeType = OWNER_SVG_ELEMENT in node ? /* istanbul ignore next */ 'svg' : 'html';\n    let fastPath = false;\n    let oldValue;\n    const anyContent = value => {\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          if (fastPath) {\n            if (oldValue !== value) {\n              oldValue = value;\n              childNodes[0].textContent = value;\n            }\n          } else {\n            fastPath = true;\n            oldValue = value;\n            childNodes = domdiff(\n              node.parentNode,\n              childNodes,\n              [text(node, value)],\n              diffOptions\n            );\n          }\n          break;\n        case 'function':\n          anyContent(value(node));\n          break;\n        case 'object':\n        case 'undefined':\n          if (value == null) {\n            fastPath = false;\n            childNodes = domdiff(\n              node.parentNode,\n              childNodes,\n              [],\n              diffOptions\n            );\n            break;\n          }\n        default:\n          fastPath = false;\n          oldValue = value;\n          if (isArray(value)) {\n            if (value.length === 0) {\n              if (childNodes.length) {\n                childNodes = domdiff(\n                  node.parentNode,\n                  childNodes,\n                  [],\n                  diffOptions\n                );\n              }\n            } else {\n              switch (typeof value[0]) {\n                case 'string':\n                case 'number':\n                case 'boolean':\n                  anyContent({html: value});\n                  break;\n                case 'object':\n                  if (isArray(value[0])) {\n                    value = value.concat.apply([], value);\n                  }\n                  if (isPromise_ish(value[0])) {\n                    Promise.all(value).then(anyContent);\n                    break;\n                  }\n                default:\n                  childNodes = domdiff(\n                    node.parentNode,\n                    childNodes,\n                    value,\n                    diffOptions\n                  );\n                  break;\n              }\n            }\n          } else if (canDiff(value)) {\n            childNodes = domdiff(\n              node.parentNode,\n              childNodes,\n              value.nodeType === DOCUMENT_FRAGMENT_NODE ?\n                slice.call(value.childNodes) :\n                [value],\n              diffOptions\n            );\n          } else if (isPromise_ish(value)) {\n            value.then(anyContent);\n          } else if ('placeholder' in value) {\n            invokeAtDistance(value, anyContent);\n          } else if ('text' in value) {\n            anyContent(String(value.text));\n          } else if ('any' in value) {\n            anyContent(value.any);\n          } else if ('html' in value) {\n            childNodes = domdiff(\n              node.parentNode,\n              childNodes,\n              slice.call(\n                createContent(\n                  [].concat(value.html).join(''),\n                  nodeType\n                ).childNodes\n              ),\n              diffOptions\n            );\n          } else if ('length' in value) {\n            anyContent(slice.call(value));\n          } else {\n            anyContent(Intent.invoke(value, anyContent));\n          }\n          break;\n      }\n    };\n    return anyContent;\n  },\n\n  // style or textareas don't accept HTML as content\n  // it's pointless to transform or analyze anything\n  // different from text there but it's worth checking\n  // for possible defined intents.\n  text(node) {\n    let oldValue;\n    const textContent = value => {\n      if (oldValue !== value) {\n        oldValue = value;\n        const type = typeof value;\n        if (type === 'object' && value) {\n          if (isPromise_ish(value)) {\n            value.then(textContent);\n          } else if ('placeholder' in value) {\n            invokeAtDistance(value, textContent);\n          } else if ('text' in value) {\n            textContent(String(value.text));\n          } else if ('any' in value) {\n            textContent(value.any);\n          } else if ('html' in value) {\n            textContent([].concat(value.html).join(''));\n          } else if ('length' in value) {\n            textContent(slice.call(value).join(''));\n          } else {\n            textContent(Intent.invoke(value, textContent));\n          }\n        } else if (type === 'function') {\n          textContent(value(node));\n        } else {\n          node.textContent = value == null ? '' : value;\n        }\n      }\n    };\n    return textContent;\n  }\n};\n","import WeakMap from '@ungap/weakmap';\n\nvar isNoOp = typeof document !== 'object';\n\nvar templateLiteral = function (tl) {\n  var RAW = 'raw';\n  var isBroken = function (UA) {\n    return /(Firefox|Safari)\\/(\\d+)/.test(UA) &&\n          !/(Chrom|Android)\\/(\\d+)/.test(UA);\n  };\n  var broken = isBroken((document.defaultView.navigator || {}).userAgent);\n  var FTS = !(RAW in tl) ||\n            tl.propertyIsEnumerable(RAW) ||\n            !Object.isFrozen(tl[RAW]);\n  if (broken || FTS) {\n    var forever = {};\n    var foreverCache = function (tl) {\n      for (var key = '.', i = 0; i < tl.length; i++)\n        key += tl[i].length + '.' + tl[i];\n      return forever[key] || (forever[key] = tl);\n    };\n    // Fallback TypeScript shenanigans\n    if (FTS)\n      templateLiteral = foreverCache;\n    // try fast path for other browsers:\n    // store the template as WeakMap key\n    // and forever cache it only when it's not there.\n    // this way performance is still optimal,\n    // penalized only when there are GC issues\n    else {\n      var wm = new WeakMap;\n      var set = function (tl, unique) {\n        wm.set(tl, unique);\n        return unique;\n      };\n      templateLiteral = function (tl) {\n        return wm.get(tl) || set(tl, foreverCache(tl));\n      };\n    }\n  } else {\n    isNoOp = true;\n  }\n  return TL(tl);\n};\n\nexport default TL;\n\nfunction TL(tl) {\n  return isNoOp ? tl : templateLiteral(tl);\n}\n","import unique from '@ungap/template-literal';\n\nexport default function (template) {\n  var length = arguments.length;\n  var args = [unique(template)];\n  var i = 1;\n  while (i < length)\n    args.push(arguments[i++]);\n  return args;\n};\n","import WeakMap from '@ungap/weakmap';\nimport tta from '@ungap/template-tag-arguments';\n\nimport Wire from 'hyperhtml-wire';\n\nimport {Tagger} from '../objects/Updates.js';\n\n// all wires used per each context\nconst wires = new WeakMap;\n\n// A wire is a callback used as tag function\n// to lazily relate a generic object to a template literal.\n// hyper.wire(user)`<div id=user>${user.name}</div>`; => the div#user\n// This provides the ability to have a unique DOM structure\n// related to a unique JS object through a reusable template literal.\n// A wire can specify a type, as svg or html, and also an id\n// via html:id or :id convention. Such :id allows same JS objects\n// to be associated to different DOM structures accordingly with\n// the used template literal without losing previously rendered parts.\nconst wire = (obj, type) => obj == null ?\n  content(type || 'html') :\n  weakly(obj, type || 'html');\n\n// A wire content is a virtual reference to one or more nodes.\n// It's represented by either a DOM node, or an Array.\n// In both cases, the wire content role is to simply update\n// all nodes through the list of related callbacks.\n// In few words, a wire content is like an invisible parent node\n// in charge of updating its content like a bound element would do.\nconst content = type => {\n  let wire, tagger, template;\n  return function () {\n    const args = tta.apply(null, arguments);\n    if (template !== args[0]) {\n      template = args[0];\n      tagger = new Tagger(type);\n      wire = wireContent(tagger.apply(tagger, args));\n    } else {\n      tagger.apply(tagger, args);\n    }\n    return wire;\n  };\n};\n\n// wires are weakly created through objects.\n// Each object can have multiple wires associated\n// and this is thanks to the type + :id feature.\nconst weakly = (obj, type) => {\n  const i = type.indexOf(':');\n  let wire = wires.get(obj);\n  let id = type;\n  if (-1 < i) {\n    id = type.slice(i + 1);\n    type = type.slice(0, i) || 'html';\n  }\n  if (!wire)\n    wires.set(obj, wire = {});\n  return wire[id] || (wire[id] = content(type));\n};\n\n// A document fragment loses its nodes \n// as soon as it is appended into another node.\n// This has the undesired effect of losing wired content\n// on a second render call, because (by then) the fragment would be empty:\n// no longer providing access to those sub-nodes that ultimately need to\n// stay associated with the original interpolation.\n// To prevent hyperHTML from forgetting about a fragment's sub-nodes,\n// fragments are instead returned as an Array of nodes or, if there's only one entry,\n// as a single referenced node which, unlike fragments, will indeed persist\n// wire content throughout multiple renderings.\n// The initial fragment, at this point, would be used as unique reference to this\n// array of nodes or to this single referenced node.\nconst wireContent = node => {\n  const childNodes = node.childNodes;\n  const {length} = childNodes;\n  return length === 1 ?\n    childNodes[0] :\n    (length ? new Wire(childNodes) : node);\n};\n\nexport { content, weakly };\nexport default wire;\n","import WeakMap from '@ungap/weakmap';\nimport tta from '@ungap/template-tag-arguments';\n\nimport {OWNER_SVG_ELEMENT} from '../shared/constants.js';\nimport {Tagger} from '../objects/Updates.js';\n\n// a weak collection of contexts that\n// are already known to hyperHTML\nconst bewitched = new WeakMap;\n\n// better known as hyper.bind(node), the render is\n// the main tag function in charge of fully upgrading\n// or simply updating, contexts used as hyperHTML targets.\n// The `this` context is either a regular DOM node or a fragment.\nfunction render() {\n  const wicked = bewitched.get(this);\n  const args = tta.apply(null, arguments);\n  if (wicked && wicked.template === args[0]) {\n    wicked.tagger.apply(null, args);\n  } else {\n    upgrade.apply(this, args);\n  }\n  return this;\n}\n\n// an upgrade is in charge of collecting template info,\n// parse it once, if unknown, to map all interpolations\n// as single DOM callbacks, relate such template\n// to the current context, and render it after cleaning the context up\nfunction upgrade(template) {\n  const type = OWNER_SVG_ELEMENT in this ? 'svg' : 'html';\n  const tagger = new Tagger(type);\n  bewitched.set(this, {tagger, template: template});\n  this.textContent = '';\n  this.appendChild(tagger.apply(null, arguments));\n}\n\nexport default render;\n","/*! (c) Andrea Giammarchi (ISC) */\nimport WeakMap from '@ungap/weakmap';\nimport WeakSet from '@ungap/essential-weakset';\n\nimport diff from 'domdiff';\nimport Component, {setup} from './classes/Component.js';\nimport Intent from './objects/Intent.js';\nimport {observe, Tagger} from './objects/Updates.js';\nimport wire, {content, weakly} from './hyper/wire.js';\nimport render from './hyper/render.js';\n\n// all functions are self bound to the right context\n// you can do the following\n// const {bind, wire} = hyperHTML;\n// and use them right away: bind(node)`hello!`;\nconst bind = context => render.bind(context);\nconst define = Intent.define;\nconst tagger = Tagger.prototype;\n\nhyper.Component = Component;\nhyper.bind = bind;\nhyper.define = define;\nhyper.diff = diff;\nhyper.hyper = hyper;\nhyper.observe = observe;\nhyper.tagger = tagger;\nhyper.wire = wire;\n\n// exported as shared utils\n// for projects based on hyperHTML\n// that don't necessarily need upfront polyfills\n// i.e. those still targeting IE\nhyper._ = {\n  WeakMap,\n  WeakSet\n};\n\n// the wire content is the lazy defined\n// html or svg property of each hyper.Component\nsetup(content);\n\n// everything is exported directly or through the\n// hyperHTML callback, when used as top level script\nexport {Component, bind, define, diff, hyper, observe, tagger, wire};\n\n// by default, hyperHTML is a smart function\n// that \"magically\" understands what's the best\n// thing to do with passed arguments\nexport default function hyper(HTML) {\n  return arguments.length < 2 ?\n    (HTML == null ?\n      content('html') :\n      (typeof HTML === 'string' ?\n        hyper.wire(null, HTML) :\n        ('raw' in HTML ?\n          content('html')(HTML) :\n          ('nodeType' in HTML ?\n            hyper.bind(HTML) :\n            weakly(HTML, 'html')\n          )\n        )\n      )) :\n    ('raw' in HTML ?\n      content('html') : hyper.wire\n    ).apply(null, arguments);\n}\n","import HyperElement from './element'\n\ninterface ClassDescriptor<T> {\n  kind: 'class'\n  elements: Descriptor<T>[];\n  finisher?: (clazz: T) => undefined | T,\n  [Symbol.toStringTag]: \"Descriptor\"\n}\n\n// From the TC39 Decorators proposal\ninterface Descriptor<T> {\n  kind: 'field' | 'method' \n  key: PropertyKey\n  placement: 'static'|'prototype'|'own'\n  initializer?: () => unknown\n  extras?: Descriptor<T>[]\n  finisher?: (clazz: T) => undefined | T\n  descriptor: PropertyDescriptor,\n  [Symbol.toStringTag]: \"Descriptor\"\n}\n\n\nexport const customElement = (\n  name: string,\n  options?: ElementDefinitionOptions\n) => <T extends typeof HTMLElement>(TargetOrDescriptor: T | ClassDescriptor<T>) => {\n  const define = (clazz: T) => {\n    customElements.define(name, clazz, options)\n  }\n  if (TargetOrDescriptor instanceof Function) return define(TargetOrDescriptor)\n  if (TargetOrDescriptor.kind === 'class') {\n    return {...TargetOrDescriptor, finisher: define} as unknown as T\n  }\n  else throw new TypeError('customElement decorator can only be applied to classes that descend HTMLElement')\n}\n\nexport const attribute = (\n  attribute: string,\n  type: (typeof String | typeof Boolean | typeof Number) = String\n) => <T extends HTMLElement>(\n  elementOrDescriptor: T | Descriptor<typeof HyperElement>,\n  property?: string\n) => {\n  if (elementOrDescriptor instanceof HTMLElement) return\n  const descriptor: Descriptor<typeof HyperElement> = {\n    ...elementOrDescriptor,\n    placement: 'prototype',\n    kind: 'method',\n    descriptor: {\n      get (this: T) {\n        if (type === String) return this.getAttribute(attribute)\n        if (type === Number) return Number(this.getAttribute(attribute))\n        if (type === Boolean) return this.hasAttribute(attribute)\n      },\n      set (this: T, value: unknown) {\n        switch (type) {\n          case String: {\n            if (typeof value === 'string') {\n              return this.setAttribute(attribute, value)\n            }\n            throw new TypeError(`This property only accepts string as value, instead got ${typeof value}`)\n          }\n          case Number: {\n            if (typeof value === 'number') {\n              return this.setAttribute(attribute, value.toString())\n            }\n            throw new TypeError(`This property only accepts number as value, instead got ${typeof value}`)\n          }\n          case Boolean: {\n            this.toggleAttribute(attribute, Boolean(value))\n            return\n          }\n          default: {\n            if (typeof value === 'undefined') {\n              return this.removeAttribute(attribute)\n            }\n          }\n        }\n      }\n    },\n    initializer: undefined,\n    finisher: (clazz) => {\n      if (!clazz.hasOwnProperty('observedAttributesInitializer')) {\n        Object.defineProperty(clazz, 'observedAttributesInitializer', {\n          value: new Set()\n        })\n      }\n      clazz.observedAttributesInitializer.add({\n        ...elementOrDescriptor,\n        attribute,\n        type\n      })\n      const observedAttributes = clazz.observedAttributes\n      Object.defineProperty(clazz, 'observedAttributes', {\n        configurable: true,\n        value: [...observedAttributes, attribute]\n      })\n      return clazz\n    }\n  }\n  return descriptor as unknown as void\n}\n","import {bind, wire, BoundTemplateFunction, WiredTemplateFunction} from 'hyperhtml'\n\n\nexport interface AttributeInitializer {\n  attribute: string,\n  key: PropertyKey,\n  type: typeof String | typeof Boolean | typeof Number\n  initializer?: () => unknown\n}\n\n/**\n * reference to the root of each HyperElement\n */\nconst roots = new WeakMap<HyperElement, ShadowRoot | HyperElement>()\n/**\n * reference to the handle that indicates if first render has already happened\n */\nconst firstRenderHandles = new WeakMap<HyperElement, number>()\n\n/**\n * small polyfill for the **requestIdleCallback** functionality\n */\nif (!window.requestIdleCallback) {\n  window.requestIdleCallback = (cb) => setTimeout(cb, 0)\n  window.cancelIdleCallback = (handle) => clearTimeout(handle)\n}\n\nexport default abstract class HyperElement extends HTMLElement {\n  public static readonly observedAttributes: string[] = []\n  public static readonly observedAttributesInitializer: Set<AttributeInitializer>\n  public static readonly css: string | null = null\n  public static styleSheet?: CSSStyleSheet | HTMLStyleElement\n  public static readonly shadowRootInit: ShadowRootInit = {mode: 'open'}\n  public static readonly tabIndex?: number\n  public static readonly role?: string\n  /**\n   * creates the root that the methods _html_ and _wire_ refer to\n   * by default the this function will create a shadow root\n   * using as argument the value provided on _Constructor.shadowRootInit\n   * @param element the element\n   */\n  public static createRoot<Element extends HyperElement>(element: Element): ShadowRoot | Element {\n    const {shadowRootInit} = this\n    return element.attachShadow(shadowRootInit)\n  }\n  public html: BoundTemplateFunction<HyperElement | ShadowRoot>\n  public wire: (type_id: string) => WiredTemplateFunction\n  constructor () {\n    super()\n    const constructor = this.constructor as typeof HyperElement\n    roots.set(this, constructor.createRoot(this))\n    this.html = createHTML(this)\n    this.wire = createWire(this)\n    if (!constructor.styleSheet) createStyleSheet(constructor)\n    /**\n     * render as soon as event loop is idle\n     * ensuring that the element **synchronous** construction is over before rendering\n     */\n    firstRenderHandles.set(this, requestIdleCallback(() => firstRender(this)))\n  }\n  protected connectedCallback () {\n    const constructor = this.constructor as typeof HyperElement\n    addRole(this)\n    addTabIndex(this)\n    addCSSStyleSheet(this)\n    for (const attributeInitializer of constructor.observedAttributesInitializer) {\n      initializeAttribute(this, attributeInitializer)\n      upgradeProperty(this, attributeInitializer.key)\n    }\n    /**\n     * if by any reason the rendering hasn't happened yet, then render it\n     */\n    firstRender(this)\n  }\n  protected disconnectedCallback () {}\n  protected attributeChangedCallback () {\n    if (!firstRenderHandles.has(this) && this.render instanceof Function) {\n      this.render()\n    }\n  }\n  public abstract render? (): void\n}\n\n\nfunction createHTML(component: HyperElement) {\n  const root = roots.get(component)!\n  const html = bind(root)\n  return (template: TemplateStringsArray, ...values: any[]) => {\n    const result = html(template, ...values)\n    addStyleElement(component)\n    return result\n  }\n}\n\nfunction createWire(component: HyperElement) {\n  const root = roots.get(component)!\n  return (type_id: string) => wire(root, type_id)\n}\n\nfunction createStyleSheet(constructor: typeof HyperElement) {\n  if ('adoptedStyleSheets' in ShadowRoot.prototype) {\n    constructor.styleSheet = new CSSStyleSheet()\n  } else {\n    constructor.styleSheet = document.createElement('style')\n    constructor.styleSheet.textContent = constructor.css\n  }\n}\n\n\nfunction addCSSStyleSheet(component: HyperElement) {\n  const {css, styleSheet} = component.constructor as typeof HyperElement\n  const root = roots.get(component)\n  if (styleSheet && css && root instanceof ShadowRoot) {\n    if (styleSheet instanceof CSSStyleSheet) {\n      root.adoptedStyleSheets = [styleSheet]\n      if (styleSheet.rules.length === 0) styleSheet.replaceSync(css)\n    }\n  }\n}\n\nfunction addStyleElement(component: HyperElement) {\n  const {styleSheet} = component.constructor as typeof HyperElement\n  const root = roots.get(component)\n  if (styleSheet instanceof HTMLStyleElement && root instanceof ShadowRoot) {\n    root.appendChild(styleSheet.cloneNode(true))\n  }\n}\n\nfunction addRole(component: HyperElement) {\n  const {role} = component.constructor as typeof HyperElement\n  if (!component.hasAttribute('role') && typeof role === 'string') {\n    component.setAttribute('role', role)\n  }\n}\n\nfunction addTabIndex(component: HyperElement) {\n  const {tabIndex} = component.constructor as typeof HyperElement\n  if (!component.hasAttribute('tabindex') && typeof tabIndex === 'number') {\n    component.tabIndex = tabIndex\n  }\n}\n\nfunction upgradeProperty(component: HyperElement, key: PropertyKey) {\n  if (component.hasOwnProperty(key)) {\n    const value = Reflect.get(component, key)\n    Reflect.deleteProperty(component, key)\n    Reflect.set(component, key, value)\n  }\n}\n\nfunction initializeAttribute(component: HyperElement, {key, initializer, attribute, type}: AttributeInitializer) {\n  const hasAttribute = component.hasAttribute(attribute)\n  if (initializer && !hasAttribute) {\n    Reflect.set(component, key, initializer())\n  } else if (hasAttribute) {\n    const value = component.getAttribute(attribute)\n    if (type === String) Reflect.set(component, key, value)\n    else if (type === Number) Reflect.set(component, key, Number(value))\n    else if (type === Boolean) Reflect.set(component, key, value === 'true' || value === '' || value === attribute)\n  }\n}\n\n\nfunction firstRender (element: HyperElement) {\n  if (firstRenderHandles.has(element)) {\n    cancelIdleCallback(firstRenderHandles.get(element)!)\n    firstRenderHandles.delete(element)\n    if (element.render instanceof Function) element.render()\n  }\n}\n","export * from './decorators'\nexport * from './element'\n\nexport {default} from './element'\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","import HyperElement, {attribute} from '~/utils/hyper-element'\n\nexport default class PortDetails extends HyperElement {\n  public static readonly tabIndex = 0\n  public static readonly css = /*css*/`\n    :host {\n      display: block;\n    }\n    :host([sticky][open]) button {\n      position: sticky;\n      top: 0;\n    }\n\n    :host(:not([open])) slot:not([name]) {\n      display: none\n    }\n\n    :host([hidden]) {\n      display: none;\n    }\n\n    slot {\n      display: block;\n    }\n\n\n    slot[name=\"summary\"] {\n      cursor: pointer;\n    }\n    slot[name=\"summary\"]:focus {\n      outline: none;\n    }\n    button {\n      width: 100%;\n      text-align: unset;\n      -webkit-box-sizing: content-box;\n      -moz-box-sizing: content-box;\n      box-sizing: content-box;\n      background: none;\n      border: 0;\n      color: inherit;\n      font: inherit;\n      line-height: normal;\n      overflow: visible;\n      padding: 0;\n      -webkit-appearance: button;\n      -webkit-user-select: none;\n      -moz-user-select: none;\n        -ms-user-select: none;\n    }\n    button::-moz-focus-inner {\n      border: 0;\n      padding: 0;\n    }\n  `\n  \n  @attribute('open', Boolean)\n  public open: boolean = false\n  @attribute('sticky', Boolean)\n  public sticky: boolean = false\n\n  public render () {\n    this.html`\n      <button\n        id=\"button\"\n        tabindex=${-1}\n        aria-controls=\"content\"\n        aria-expanded=${this.open ? 'true' : 'false'}\n        onclick=${this._handleClick}\n      >\n        <slot name=\"summary\"/>\n      </button>\n      <slot id=\"content\"/>\n    `\n  }\n  public connectedCallback () {\n    super.connectedCallback()\n    this.addEventListener('keydown', this._handleKeyDown, {passive: true})\n  }\n  public disconnectedCallback () {\n    super.disconnectedCallback()\n    this.removeEventListener('keydown', this._handleKeyDown)\n  }\n  public toggle () {\n    this.open = !this.open\n    this.dispatchEvent(new Event('toggle', {bubbles: false, cancelable: false}))\n    if (this.open) {\n      requestAnimationFrame(() => (\n        this.scrollIntoView({behavior: 'smooth'})\n      ))\n    }\n  }\n  private _handleClick = (ev: MouseEvent) => this.toggle()\n  private _handleKeyDown = (ev: KeyboardEvent) => {\n    const button = this.shadowRoot!.getElementById('button') as HTMLButtonElement\n    if (ev.target === this && button && (ev.code === 'Space' || ev.code === 'Enter')) {\n      button.click()\n    }\n  }\n}\n"],"sourceRoot":""}